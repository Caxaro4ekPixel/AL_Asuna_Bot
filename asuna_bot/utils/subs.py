import re
from aiogram.types import  BufferedInputFile
from asuna_bot.config import __version__
import io

def _parse_text(element) -> str:
        text = ','.join(element['text']).strip().replace("\\N", " ").replace("  ", " ")
        
        if text.startswith('—'):
            text = text.replace("—", "")

        if element['fx']: 
            text = f"[{text}]"
        else:
            tags = ("\\fn", "\\shad", "\\bord", "\\fade", "\\move", "\\pos", "\\fsc")
            for tag in tags:
                if tag in text:
                    text = f"[{text}]"
                    break
        
        if element['name'] != '' and element['name'] != 'НАДПИСЬ':
            text = f"({element['name']}) {text}"

        return re.sub(r'{.*?}', '', text)

def _sort_by_time(parsed_lines):
    return parsed_lines['start']

def convert_to_srt(file_in_bytes: bytes, file_name) -> BufferedInputFile:
    raw_lines = file_in_bytes.decode('utf-8').split('\n')
    # remove everything but Dialogue
    lines = [line for line in raw_lines if line.startswith('Dialogue: ')]

    parsed_lines = []
    for line in lines:
        l = line.split(',')  # noqa: E741
        parsed_lines.append({
            'start': l[1].replace(".", ","), 
            'end': l[2].replace(".", ","),
            'name': l[4],
            'fx': l[8],
            'text': l[9:]
        })
    
    parsed_lines.sort(key=_sort_by_time)

    # Clean text
    _del = []
    for i, line in enumerate(parsed_lines):
        text = parsed_lines[i]['text'] = _parse_text(line)
        start = line['start']
        end = line['end']

        if i > 0:
            if parsed_lines[i] == parsed_lines[i-1]:
                _del.append(i)

    parsed_lines = [i for j, i in enumerate(parsed_lines) if j not in _del]

    srt_events = []
    i = 0
    while i < len(parsed_lines):
        element = parsed_lines[i]
        start = element['start']
        end = element['end']
        text = element['text']
        
        # check if the end time of the current line is 
        # greater than the start time of the next line
        while i < len(parsed_lines) - 1:
            next_element = parsed_lines[i + 1]
            next_start = next_element['start']
            next_end = next_element['end']
            next_text = next_element['text']

            if end > next_start and text != next_text:
                if '[' not in next_text:
                    text += '\n—' + next_text
                else: 
                    text += '\n' + next_text
                end = next_end
                i += 1
            else:
                break          

        srt_events.append((start, end, text))
        i += 1


    # write the SRT file
    srt_text = "\n".join([
            f"{i}\n0{start}0 --> 0{end}0\n{text}\n" 
            for i, (start, end, text) 
            in enumerate(srt_events, 2)
        ])
    
    asuna_str = (f"1\n00:00:00,00 --> 00:00:00,00\n"
                 f"Generated by Asuna Bot v{__version__}\n\n")

    f_bytes = io.BytesIO()
    f_bytes.write(bytes(asuna_str, 'utf-8'))
    f_bytes.write(bytes(srt_text, 'utf-8'))
    filename = file_name.replace('.ass', '.srt')
    f_bytes.seek(0)
    file = BufferedInputFile(f_bytes.read(), filename)
    return file 